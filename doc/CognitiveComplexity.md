# Когнитивная сложность

> "Когнитивная сложность, потому что тестируемость! = Понятность" (с) Г. Энн Кэмпбелл

Достаточно известной метрикой сложности кода является [Цикломатическая сложность](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C), которая показывает сложность тестирования кода, но не говорит о том, насколько он сложночитаем.

Код с одной и той же цикломатической сложностью может по разному восприниматься человеком:

Пример 1.1

```bsl
Функция Посчитаем(МаксимальноеЗначение)      // +1
    Результат = 1;
    Для Ит = 1 По МаксимальноеЗначение Цикл  // +1
        Для Сч = 2 По Ит Цикл                // +1
            Если Ит % Сч = 0 Тогда           // +1
                Продолжить;
            КонецЕсли;
            Результат = Результат + 1;
        КонецЦикла;
    КонецЦикла;
    Вовзрат Результат;
КонецФункции                                 // Цикломатическая сложность = 4
```

Пример 1.2

```bsl
Функция Выберем(Анализируемое)              // +1
    Если Анализируемое % 2 = 0 Тогда        // +1
        Возврат "Четный";
    ИначеЕсли Анализируемое % 2 = 1 Тогда   // +1
        Возврат "Нечетный";
    Иначе                                   // +1
        Возврат "Такого не бывает";
    КонецЕсли;    
КонецФункции                                // Цикломатическая сложность = 4
```

В связи с этим, была введена метрика `Когнитивная сложность`, отражающая сложность кода для восприятия.

## Базовые правила `Когнитивной сложности`

1. Когнитивная сложность инкрементируется на каждый блок кода, в котором происходит отклонение от линейной структуры (условия, циклы)
2. Когнитивная сложность инкрементируется на каждый уровень вложенности нелинейных блоков
3. При расчете когнитивной сложности игнорируется "простой" код, легко воспринимаемый при записи в одну строку.

## `Когнитивная сложность` в действии

Для того, чтобы понять, как работает `когнитивная сложность` воспользуемся примерами выше и рассчитаем ее.

Пример 2.1

```bsl
//                                          Цикломатическая сложность   // Когнитивная сложность
Функция Посчитаем(МаксимальноеЗначение)      // +1                          
    Результат = 1;
    Для Ит = 1 По МаксимальноеЗначение Цикл  // +1                      // +1
        Для Сч = 2 По Ит Цикл                // +1                      // +2 (+1 блок +1 вложенность)
            Если Ит % Сч = 0 Тогда           // +1                      // +3 (+1 блок +2 вложенность)
                Продолжить;                                             // +1
            КонецЕсли;
            Результат = Результат + 1;
        КонецЦикла;
    КонецЦикла;
    Вовзрат Результат;
КонецФункции                                 // =4                      // =7
```

Пример 2.2

```bsl
//                                          Цикломатическая сложность   // Когнитивная сложность
Функция Выберем(Анализируемое)              // +1
    Если Анализируемое % 2 = 0 Тогда        // +1                       // +1
        Возврат "Четный";
    ИначеЕсли Анализируемое % 2 = 1 Тогда   // +1                       // +1
        Возврат "Нечетный";
    Иначе                                   // +1
        Возврат "Такого не бывает";
    КонецЕсли;    
КонецФункции                                // =4                       // =2
```

```bsl
//                                          Цикломатическая сложность   // Когнитивная сложность
Функция ВернемСумму(Слагаемое1, Слагаемое2) // +1
    Возврат Слагаемое1 + Слагаемое2;
КонецФункции                                // =1                       // =0
```

## Снижение когнитивной сложности

Снижение когнитивной сложности приводит к улучшению восприятия кода, что в итоге упрощает его поддержку и поиск потенциальных точек роста.

Ниже приведены примеры **МИНИМАЛЬНОГО** рефакторинга, приводящие к снижению когнтивной сложности _(и цикломатической тоже)_

### Пример 3.1

До исправления

```bsl
//                                                              Цикломатическая сложность   // Когнитивная сложность
Если Параметр.Свойство("СТекущегоШага") Тогда                           // +1               // +1
    Если Параметр.СТекущегоШага Тогда                                   // +1               // +2 (вложенность 1)
        НадоВыполнитьСценарийСоСтрокиПереданнойИзвне = Истина;
        НомерСтрокиСценарияПереданныйИзвне           = НомерСтрокиДля
        Если ФормаVanessaAutomationОткрылась Тогда                      // +1               // +3 (вложенность 2)
            ДопПараметры = Новый Структура;
            ДопПараметры.Вставить("ЗапуститьСценарий",Истина);
            ЗагрузитьФичи(ДопПараметры);
        КонецЕсли;     
        Возврат;                                                        // +0               // +1
    КонецЕсли;     
КонецЕсли;                                                              // =3               // =7        

```

После исправления

```bsl
//                                                              Цикломатическая сложность   // Когнитивная сложность
Если Параметр.Свойство("СТекущегоШага")                                 // +1               // +1
        И Параметр.СТекущегоШага Тогда                                  // +1               // +1    
    НадоВыполнитьСценарийСоСтрокиПереданнойИзвне = Истина;
    НомерСтрокиСценарияПереданныйИзвне           = НомерСтрокиДля
    Если ФормаVanessaAutomationОткрылась Тогда                          // +1               // +2 (вложенность 1)
        ДопПараметры = Новый Структура;
        ДопПараметры.Вставить("ЗапуститьСценарий",Истина);
        ЗагрузитьФичи(ДопПараметры);
    КонецЕсли;     
    Возврат;                                                            // +0               // +1
КонецЕсли;                                                              // =3               // =5
```


### Пример 3.2

До исправления

```bsl
//                                                  Цикломатическая сложность   // Когнитивная сложность
Для Каждого Элем Из ПараметрыФайла Цикл                         // +1               // +1
    Если Лев(Элем.Ключ, 11) = "ЗаписьВидео" Тогда               // +1               // +2 (вложенность 1)
        Если Найти(Элем.Ключ,"ВодянойЗнак") > 0 Тогда           // +1               // +3 (вложенность 2)
            Продолжить;                                         // +0               // +1
        ИначеЕсли Найти(Элем.Ключ,"ЗаписьП1") > 0 Тогда         // +1               // +3 (вложенность 2)
            Продолжить;                                         // +0               // +1
        ИначеЕсли Найти(Элем.Ключ,"ЗаписьП2") > 0 Тогда         // +1               // +3 (вложенность 2)
            Продолжить;                                         // +0               // +1
        ИначеЕсли Найти(Элем.Ключ,"ЗаписьК1") > 0 Тогда         // +1               // +3 (вложенность 2)
            Продолжить;                                         // +0               // +1
        КонецЕсли;     
            
        Если Найти(Элем.Ключ,"СловарьЗаменСписок") > 0 Тогда    // +1               // +3 (вложенность 2)
            Объект.ЗаписьВидеоСловарьЗамен.Очистить();
            Для Каждого ПутьКСловарюЗ Из Элем.Значение Цикл     // +1               // +4 (вложенность 3)
                Объект.ЗаписьВидеоСловарьЗамен.Добавить(ПреобразоватьПутьСТочкамиКНормальномуПути(ПутьКСловарюЗамен));
            КонецЦикла;    
                
            Продолжить;                                         // +0               // +1
        КонецЕсли;     
            
        Если Найти(Элем.Ключ,"СловарьЗамен") > 0 Тогда          // +1               // +3 (вложенность 2)
            Объект.ЗаписьВидеоСловарьЗамен.Очистить();
            Объект.ЗаписьВидеоСловарьЗамен.Добавить(ПреобразоватьПутьСТочкамиКНормальномуПути(Элем.Значение));
            Продолжить;                                         // +0               // +1
        КонецЕсли;     
            
        Значение = Элем.Значение;
        Если Лев(Элем.Значение, 1) = "." Тогда                  // +1               // +3 (вложенность 2)
            Значение = ПреобразоватьПутьСТочкамиКНормальномуПути(Элем.Значение);
        КонецЕсли;
            
        Объект[Элем.Ключ] = Значение;
    КонецЕсли;
КонецЦикла;                                                     // =10             // =33
```

После исправления

```bsl
//                                                  Цикломатическая сложность   // Когнитивная сложность
Для Каждого Элем Из ПараметрыФайла Цикл                         // +1               // +1
    Если Лев(Элем.Ключ, 11) <> "ЗаписьВидео"                    // +1               // +2 (вложенность 1)
            ИЛИ Найти(Элем.Ключ,"ВодянойЗнак")                  // +1               // +2 (вложенность 1)
            ИЛИ Найти(Элем.Ключ,"ЗаписьП1")                     // +1               // +2 (вложенность 1)
            ИЛИ Найти(Элем.Ключ,"ЗаписьП2")                     // +1               // +2 (вложенность 1)
            ИЛИ Найти(Элем.Ключ,"ЗаписьК1")                     // +1               // +2 (вложенность 1)
        Продолжить;                                             // +0               // +1
    КонецЕсли;
                
    Если Найти(Элем.Ключ,"СловарьЗаменСписок") > 0 Тогда        // +1               // +2 (вложенность 1)
    
        Объект.ЗаписьВидеоСловарьЗамен.Очистить();
        Для Каждого ПутьКСловарюЗ Из Элем.Значение Цикл         // +1               // +3 (вложенность 2)
            Объект.ЗаписьВидеоСловарьЗамен.Добавить(ПреобразоватьПутьСТочкамиКНормальномуПути(ПутьКСловарюЗамен));
        КонецЦикла;                    
    
    ИначеЕсли Найти(Элем.Ключ,"СловарьЗамен") > 0 Тогда         // +1               // +2 (вложенность 1)
    
        Объект.ЗаписьВидеоСловарьЗамен.Очистить();
        Объект.ЗаписьВидеоСловарьЗамен.Добавить(ПреобразоватьПутьСТочкамиКНормальномуПути(Элем.Значение));
    
    Иначе                                                       // +1               // +0
            
        Значение = Элем.Значение;
        Если Лев(Элем.Значение, 1) = "." Тогда                  // +1               // +2 (вложенность 1)
            Значение = ПреобразоватьПутьСТочкамиКНормальномуПути(Элем.Значение);
        КонецЕсли;
                
        Объект[Элем.Ключ] = Значение;

    КонецЕсли;
    
КонецЦикла;                                                     // =11             // =21
```

Как видно, минимальный рефакторинг дает результат, но незначительный, здесь стоит кардинально пересмотреть метод.
